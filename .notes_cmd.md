# Linux

# Vbird Basic
## CH5: Linux 的檔案權限與目錄配置

### Directory category:
	- /bin
	 	系統有很多放置執行檔的目錄，但/bin比較特殊。因為/bin放置的是在單人維護模式下還能夠被操作的指令。 在/bin底下的指令可以被root與一般帳號所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。
	- /boot
	 	這個目錄主要在放置開機會使用到的檔案，包括Linux核心檔案以及開機選單與開機所需設定檔等等。 Linux kernel常用的檔名為：vmlinuz，如果使用的是grub2這個開機管理程式， 則還會存在/boot/grub2/這個目錄喔！
	- /dev
		在Linux系統上，任何裝置與周邊設備都是以檔案的型態存在於這個目錄當中的。 你只要透過存取這個目錄底下的某個檔案，就等於存取某個裝置囉～比要重要的檔案有/dev/null, /dev/zero, /dev/tty, /dev/loop, /dev/sd等等
	- /etc
		系統主要的設定檔幾乎都放置在這個目錄內，例如人員的帳號密碼檔、 各種服務的啟始檔等等。一般來說，這個目錄下的各檔案屬性是可以讓一般使用者查閱的， 但是只有root有權力修改。FHS建議不要放置可執行檔(binary)在這個目錄中喔。比較重要的檔案有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue 等等。另外 FHS 還規範幾個重要的目錄最好要存在 /etc/ 目錄下喔：
		* /etc/opt(必要)：這個目錄在放置第三方協力軟體 /opt 的相關設定檔
		* /etc/X11/(建議)：與 X Window 有關的各種設定檔都在這裡，尤其是 xorg.conf 這個 X Server 的設定檔。
		* /etc/sgml/(建議)：與 SGML 格式有關的各項設定檔
		* /etc/xml/(建議)：與 XML 格式有關的各項設定檔
	- /lib
		系統的函式庫非常的多，而/lib放置的則是在開機時會用到的函式庫， 以及在/bin或/sbin底下的指令會呼叫的函式庫而已。 什麼是函式庫呢？妳可以將他想成是『外掛』，某些指令必須要有這些『外掛』才能夠順利完成程式的執行之意。 另外 FHS 還要求底下的目錄必須要存在：
		* /lib/modules/：這個目錄主要放置可抽換式的核心相關模組(驅動程式)喔！
	- /media
		media是『媒體』的英文，顧名思義，這個/media底下放置的就是可移除的裝置啦！ 包括軟碟、光碟、DVD等等裝置都暫時掛載於此。常見的檔名有：/media/floppy, /media/cdrom等等。
	- /mnt
		如果妳想要暫時掛載某些額外的裝置，一般建議妳可以放置到這個目錄中。 在古早時候，這個目錄的用途與/media相同啦！只是有了/media之後，這個目錄就用來暫時掛載用了。
	- /opt
		這個是給第三方協力軟體放置的目錄。什麼是第三方協力軟體啊？ 舉例來說，KDE這個桌面管理系統是一個獨立的計畫，不過他可以安裝到Linux系統中，因此KDE的軟體就建議放置到此目錄下了。 另外，如果妳想要自行安裝額外的軟體(非原本的distribution提供的)，那麼也能夠將你的軟體安裝到這裡來。 不過，以前的Linux系統中，我們還是習慣放置在/usr/local目錄下呢！
	- /run
		早期的 FHS 規定系統開機後所產生的各項資訊應該要放置到 /var/run 目錄下，新版的 FHS 則規範到 /run 底下。 由於 /run 可以使用記憶體來模擬，因此效能上會好很多！
	- /sbin
		Linux有非常多指令是用來設定系統環境的，這些指令只有root才能夠利用來『設定』系統，其他使用者最多只能用來『查詢』而已。 放在/sbin底下的為開機過程中所需要的，裡面包括了開機、修復、還原系統所需要的指令。 至於某些伺服器軟體程式，一般則放置到/usr/sbin/當中。至於本機自行安裝的軟體所產生的系統執行檔(system binary)， 則放置到/usr/local/sbin/當中了。常見的指令包括：fdisk, fsck, ifconfig, mkfs等等。
	- /srv
		srv可以視為『service』的縮寫，是一些網路服務啟動之後，這些服務所需要取用的資料目錄。 常見的服務例如WWW, FTP等等。舉例來說，WWW伺服器需要的網頁資料就可以放置在/srv/www/裡面。 不過，系統的服務資料如果尚未要提供給網際網路任何人瀏覽的話，預設還是建議放置到 /var/lib 底下即可。
	- /tmp
		這是讓一般使用者或者是正在執行的程序暫時放置檔案的地方。 這個目錄是任何人都能夠存取的，所以你需要定期的清理一下。當然，重要資料不可放置在此目錄啊！ 因為FHS甚至建議在開機時，應該要將/tmp下的資料都刪除唷！
	- /usr
		* /usr/bin, /bin：一般執行檔擺放的地方
		* /usr/sbin, /sbin：系統管理員常用指令集
	- /var
		* /var/log：擺放系統登錄檔案的地方
	- /home
		這是系統預設的使用者家目錄(home directory)。在你新增一個一般使用者帳號時， 預設的使用者家目錄都會規範到這裡來。比較重要的是，家目錄有兩種代號喔：
		* ~：代表目前這個使用者的家目錄
		* ~dmtsai ：則代表 dmtsai 的家目錄！
	- /lib<qual>
		用來存放與 /lib 不同的格式的二進位函式庫，例如支援 64 位元的 /lib64 函式庫等
	- /root
		系統管理員(root)的家目錄。之所以放在這裡，是因為如果進入單人維護模式而僅掛載根目錄時， 該目錄就能夠擁有root的家目錄，所以我們會希望root的家目錄與根目錄放置在同一個分割槽中。
	- /lost+found
		這個目錄是使用標準的ext2/ext3/ext4檔案系統格式才會產生的一個目錄，目的在於當檔案系統發生錯誤時， 將一些遺失的片段放置到這個目錄下。不過如果使用的是 xfs 檔案系統的話，就不會存在這個目錄了！
	- /proc
		這個目錄本身是一個『虛擬檔案系統(virtual filesystem)』喔！他放置的資料都是在記憶體當中， 例如系統核心、行程資訊(process)、周邊裝置的狀態及網路狀態等等。因為這個目錄下的資料都是在記憶體當中， 所以本身不佔任何硬碟空間啊！比較重要的檔案例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/ 等等。
	- /sys
		這個目錄其實跟/proc非常類似，也是一個虛擬的檔案系統，主要也是記錄核心與系統硬體資訊較相關的資訊。 包括目前已載入的核心模組與核心偵測到的硬體裝置資訊等等。這個目錄同樣不佔硬碟容量喔！

### Commands
- ##### chgrp [-R] dirname/filename ...
		-R : 進行遞迴(recursive)的持續變更，亦即連同次目錄下的所有檔案、目錄
			 都更新成為這個群組之意。常常用在變更某一目錄內所有的檔案之情況。

- ##### chown [-R] 帳號名稱 檔案或目錄
		-R : 進行遞迴(recursive)的持續變更，亦即連同次目錄下的所有檔案都變更
		chmod u/g/o/a +/-/= r/w/x

## CH6 Linux 檔案與目錄管理
### Commands
- #### ls
		-a  ：全部的檔案，連同隱藏檔( 開頭為 . 的檔案 ) 一起列出來(常用)
		-A  ：全部的檔案，連同隱藏檔，但不包括 . 與 .. 這兩個目錄
		-d  ：僅列出目錄本身，而不是列出目錄內的檔案資料(常用)
		-f  ：直接列出結果，而不進行排序 (ls 預設會以檔名排序！)
		-F  ：根據檔案、目錄等資訊，給予附加資料結構，例如：
		*:代表可執行檔； /:代表目錄； =:代表 socket 檔案； |:代表 FIFO 檔案； -h  ：將檔案容量以人類較易讀的方式(例如 GB, KB 等等)列出來；
		-i  ：列出 inode 號碼，inode 的意義下一章將會介紹；
		-l  ：長資料串列出，包含檔案的屬性與權限等等資料；(常用)
		-n  ：列出 UID 與 GID 而非使用者與群組的名稱 (UID與GID會在帳號管理提到！)
		-r  ：將排序結果反向輸出，例如：原本檔名由小到大，反向則為由大到小；
		-R  ：連同子目錄內容一起列出來，等於該目錄下的所有檔案都會顯示出來；
		-S  ：以檔案容量大小排序，而不是用檔名排序；
		-t  ：依時間排序，而不是用檔名。
		--color=never  ：不要依據檔案特性給予顏色顯示；
		--color=always ：顯示顏色
		--color=auto   ：讓系統自行依據設定來判斷是否給予顏色
		--full-time    ：以完整時間模式 (包含年、月、日、時、分) 輸出
		--time={atime,ctime} ：輸出 access 時間或改變權限屬性時間 (ctime) 而非內容變更時間 (modification time)

- #### touch -acdm
		-a  ：僅修訂 access time；
		-c  ：僅修改檔案的時間，若該檔案不存在則不建立新檔案；
		-d  ：後面可以接欲修訂的日期而不用目前的日期，也可以使用 --date="日期或時間"
		-m  ：僅修改 mtime ；
		-t  ：後面可以接欲修訂的時間而不用目前的時間，格式為[YYYYMMDDhhmm]

- #### umask -S

- #### chattr [+-=][ASacdistu] 檔案或目錄名稱
		+   ：增加某一個特殊參數，其他原本存在參數則不動。
		-   ：移除某一個特殊參數，其他原本存在參數則不動。
		=   ：設定一定，且僅有後面接的參數
		A  ：當設定了 A 這個屬性時，若你有存取此檔案(或目錄)時，他的存取時間 atime 將不會被修改，
		可避免 I/O 較慢的機器過度的存取磁碟。(目前建議使用檔案系統掛載參數處理這個項目)
		S  ：一般檔案是非同步寫入磁碟的(原理請參考前一章sync的說明)，如果加上 S 這個屬性時，
		當你進行任何檔案的修改，該更動會『同步』寫入磁碟中。
		a  ：當設定 a 之後，這個檔案將只能增加資料，而不能刪除也不能修改資料，只有root 才能設定這屬性
		c  ：這個屬性設定之後，將會自動的將此檔案『壓縮』，在讀取的時候將會自動解壓縮，
		但是在儲存的時候，將會先進行壓縮後再儲存(看來對於大檔案似乎蠻有用的！)
		d  ：當 dump 程序被執行的時候，設定 d 屬性將可使該檔案(或目錄)不會被 dump 備份
		i  ：這個 i 可就很厲害了！他可以讓一個檔案『不能被刪除、改名、設定連結也無法寫入或新增資料！』
		對於系統安全性有相當大的助益！只有 root 能設定此屬性
		s  ：當檔案設定了 s 屬性時，如果這個檔案被刪除，他將會被完全的移除出這個硬碟空間，
		所以如果誤刪了，完全無法救回來了喔！
		u  ：與 s 相反的，當使用 u 來設定檔案時，如果該檔案被刪除了，則資料內容其實還存在磁碟中，
		可以使用來救援該檔案喔！
		注意1：屬性設定常見的是 a 與 i 的設定值，而且很多設定值必須要身為 root 才能設定
		注意2：xfs 檔案系統僅支援 AadiS 而已

- #### lsattr
		-a ：將隱藏檔的屬性也秀出來；
		-d ：如果接的是目錄，僅列出目錄本身的屬性而非目錄內的檔名；
		-R ：連同子目錄的資料也一併列出來！

- #### which (exe file)

- #### whereis

- #### locate
		-i  ：忽略大小寫的差異；
		-c  ：不輸出檔名，僅計算找到的檔案數量
		-l  ：僅輸出幾行的意思，例如輸出五行則是 -l 5
		-S  ：輸出 locate 所使用的資料庫檔案的相關資訊，包括該資料庫紀錄的檔案/目錄數量等
		-r  ：後面可接正規表示法的顯示方式
	###### Example
	```bash
	# locate + cat
	locate -e0 target | xargs -r0 cat
	cat $(locate target)

	# [Use “locate” under some specific directory?](https://askubuntu.com/questions/33280/use-locate-under-some-specific-directory)
	locate -r ~/".*note_.*\.md"
	```

- #### find
		1. 與時間有關的選項：共有 -atime, -ctime 與 -mtime ，以 -mtime 說明
			-mtime  n ：n 為數字，意義為在 n 天之前的『一天之內』被更動過內容的檔案；
			-mtime +n ：列出在 n 天之前(不含 n 天本身)被更動過內容的檔案檔名；
			-mtime -n ：列出在 n 天之內(含 n 天本身)被更動過內容的檔案檔名。
			-newer file ：file 為一個存在的檔案，列出比 file 還要新的檔案檔名
		2. 與使用者或群組名稱有關的參數：
			-uid n ：n 為數字，這個數字是使用者的帳號 ID，亦即 UID ，這個 UID 是記錄在
			/etc/passwd 裡面與帳號名稱對應的數字。這方面我們會在第四篇介紹。
			-gid n ：n 為數字，這個數字是群組名稱的 ID，亦即 GID，這個 GID 記錄在
			/etc/group，相關的介紹我們會第四篇說明～
			-user name ：name 為使用者帳號名稱喔！例如 dmtsai
			-group name：name 為群組名稱喔，例如 users ；
			-nouser    ：尋找檔案的擁有者不存在 /etc/passwd 的人！
			-nogroup   ：尋找檔案的擁有群組不存在於 /etc/group 的檔案！
			當你自行安裝軟體時，很可能該軟體的屬性當中並沒有檔案擁有者，
			這是可能的！在這個時候，就可以使用 -nouser 與 -nogroup 搜尋。
		3. 與檔案權限及名稱有關的參數：
			-name filename：搜尋檔案名稱為 filename 的檔案；
			-size [+-]SIZE：搜尋比 SIZE 還要大(+)或小(-)的檔案。這個 SIZE 的規格有：
			c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB
			還要大的檔案，就是『 -size +50k 』
			-type TYPE    ：搜尋檔案的類型為 TYPE 的，類型主要有：一般正規檔案 (f), 裝置檔案 (b, c), 目錄 (d), 連結檔 (l), socket (s), 及 FIFO (p) 等屬性。
			-perm mode  ：搜尋檔案權限『剛好等於』 mode 的檔案，這個 mode 為類似 chmod的屬性值，舉例來說， -rwsr-xr-x 的屬性為 4755 ！
			-perm -mode ：搜尋檔案權限『必須要全部囊括 mode 的權限』的檔案，舉例來說，
			我們要搜尋 -rwxr--r-- ，亦即 0744 的檔案，使用 -perm -0744，
			當一個檔案的權限為 -rwsr-xr-x ，亦即 4755 時，也會被列出來，
			因為 -rwsr-xr-x 的屬性已經囊括了 -rwxr--r-- 的屬性了。
			-perm /mode ：搜尋檔案權限『包含任一 mode 的權限』的檔案，舉例來說，我們搜尋
			-rwxr-xr-x ，亦即 -perm /755 時，但一個檔案屬性為 -rw-------
			也會被列出來，因為他有 -rw.... 的屬性存在！
	##### Example
	```bash
	find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} \;
	find /home -name .bashrc > list 2>&1 //2>&1 means "send standard error wherever standard output is going"
	find /home -name .bashrc &> list
	```

## CH7 Linux 磁碟與檔案系統管理
### Commands
- #### dumpe2fs -h

- #### df
		-a  ：列出所有的檔案系統，包括系統特有的 /proc 等檔案系統；
		-k  ：以 KBytes 的容量顯示各檔案系統；
		-m  ：以 MBytes 的容量顯示各檔案系統；
		-h  ：以人們較易閱讀的 GBytes, MBytes, KBytes 等格式自行顯示；
		-H  ：以 M=1000K 取代 M=1024K 的進位方式；
		-T  ：連同該 partition 的 filesystem 名稱 (例如 xfs) 也列出；
		-i  ：不用磁碟容量，而以 inode 的數量來顯示

- #### du
		-a  ：列出所有的檔案與目錄容量，因為預設僅統計目錄底下的檔案量而已。
		-h  ：以人們較易讀的容量格式 (G/M) 顯示；
		-s  ：列出總量而已，而不列出每個各別的目錄佔用容量；
		-S  ：不包括子目錄下的總計，與 -s 有點差別。
		-k  ：以 KBytes 列出容量顯示；
		-m  ：以 MBytes 列出容量顯示；

- #### ln
		-s  ：如果不加任何參數就進行連結，那就是hard link，至於 -s 就是symbolic link
		-f  ：如果 目標檔 存在時，就主動的將目標檔直接移除後再建立！

- #### lsblk # 列出所有儲存裝置的意思
		-d  ：僅列出磁碟本身，並不會列出該磁碟的分割資料
		-f  ：同時列出該磁碟內的檔案系統名稱
		-i  ：使用 ASCII 的線段輸出，不要使用複雜的編碼 (再某些環境下很有用)
		-m  ：同時輸出該裝置在 /dev 底下的權限資料 (rwx 的資料)
		-p  ：列出該裝置的完整檔名！而不是僅列出最後的名字而已。
		-t  ：列出該磁碟裝置的詳細資料，包括磁碟佇列機制、預讀寫的資料量大小等

- #### blkid

- #### parted
		/dev/vda print

- #### gdisk (GPT)

- #### fdisk

- #### mkfs

- #### mount
		-a  ：依照設定檔 /etc/fstab 的資料將所有未掛載的磁碟都掛載上來
		-l  ：單純的輸入 mount 會顯示目前掛載的資訊。加上 -l 可增列 Label 名稱！
		-t  ：可以加上檔案系統種類來指定欲掛載的類型。常見的 Linux 支援類型有：xfs, ext3, ext4,
		reiserfs, vfat, iso9660(光碟格式), nfs, cifs, smbfs (後三種為網路檔案系統類型)
		-n  ：在預設的情況下，系統會將實際掛載的情況即時寫入 /etc/mtab 中，以利其他程式的運作。
		但在某些情況下(例如單人維護模式)為了避免問題會刻意不寫入。此時就得要使用 -n 選項。
		-o  ：後面可以接一些掛載時額外加上的參數！比方說帳號、密碼、讀寫權限等：
		async, sync:   此檔案系統是否使用同步寫入 (sync) 或非同步 (async) 的
		記憶體機制，請參考檔案系統運作方式。預設為 async。
		atime,noatime: 是否修訂檔案的讀取時間(atime)。為了效能，某些時刻可使用 noatime
		ro, rw:        掛載檔案系統成為唯讀(ro) 或可讀寫(rw)
		auto, noauto:  允許此 filesystem 被以 mount -a 自動掛載(auto)
		dev, nodev:    是否允許此 filesystem 上，可建立裝置檔案？ dev 為可允許
		suid, nosuid:  是否允許此 filesystem 含有 suid/sgid 的檔案格式？
		exec, noexec:  是否允許此 filesystem 上擁有可執行 binary 檔案？
		user, nouser:  是否允許此 filesystem 讓任何使用者執行 mount ？一般來說，
		mount 僅有 root 可以進行，但下達 user 參數，則可讓
		一般 user 也能夠對此 partition 進行 mount 。
		defaults:      預設值為：rw, suid, dev, exec, auto, nouser, and async
		remount:       重新掛載，這在系統出錯，或重新更新參數時，很有用！
- #### dd
	##### Example
	```bash
	dd if=/dev/zero of=/tmp/test bs=1M count=512dd if=/dev/zero of=/tmp/test bs=1M count=512
		# if    是 input file ，輸入檔案。那個 /dev/zero 是會一直輸出 0 的裝置！
  		# of    是 output file ，將一堆零寫入到後面接的檔案中。
		# bs    是每個 block 大小，就像檔案系統那樣的 block 意義；
		# count 則是總共幾個 bs 的意思。所以 bs times count 就是這個檔案的容量了！
	```


## CH8 案與檔案系統的壓縮,打包與備份
### Commands
- #### gzip
		-c  ：將壓縮的資料輸出到螢幕上，可透過資料流重導向來處理；
		-d  ：解壓縮的參數；
		-t  ：可以用來檢驗一個壓縮檔的一致性～看看檔案有無錯誤；
		-v  ：可以顯示出原檔案/壓縮檔案的壓縮比等資訊；
		-#  ：# 為數字的意思，代表壓縮等級，-1 最快，但是壓縮比最差、-9 最慢，但是壓縮比最好！預設是 -6

- #### bzip2
		-c  ：將壓縮的過程產生的資料輸出到螢幕上！
		-d  ：解壓縮的參數
		-k  ：保留原始檔案，而不會刪除原始的檔案喔！
		-z  ：壓縮的參數 (預設值，可以不加)
		-v  ：可以顯示出原檔案/壓縮檔案的壓縮比等資訊；
		-#  ：與 gzip 同樣的，都是在計算壓縮比的參數， -9 最佳， -1 最快！

- #### tar
		-c  ：建立打包檔案，可搭配 -v 來察看過程中被打包的檔名(filename)
		-t  ：察看打包檔案的內容含有哪些檔名，重點在察看『檔名』就是了；
		-x  ：解打包或解壓縮的功能，可以搭配 -C (大寫) 在特定目錄解開
		特別留意的是， -c, -t, -x 不可同時出現在一串指令列中。
		-z  ：透過 gzip  的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.gz
		-j  ：透過 bzip2 的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.bz2
		-J  ：透過 xz    的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.xz
		特別留意， -z, -j, -J 不可以同時出現在一串指令列中
		-v  ：在壓縮/解壓縮的過程中，將正在處理的檔名顯示出來！
		-f filename：-f 後面要立刻接要被處理的檔名！建議 -f 單獨寫一個選項囉！(比較不會忘記)
		-C 目錄    ：這個選項用在解壓縮，若要在特定目錄解壓縮，可以使用這個選項。
		其他後續練習會使用到的選項介紹：
		-p(小寫) ：保留備份資料的原本權限與屬性，常用於備份(-c)重要的設定檔
		-P(大寫) ：保留絕對路徑，亦即允許備份資料中含有根目錄存在之意；
		--exclude=FILE：在壓縮的過程中，不要將 FILE 打包！
	##### Example
	```bash
	tar -jcvp -f filename.tar.bz2 file
	tar -jtvp -f filename.tar.bz2
	tar -jxvp -f filename.tar.bz2
	```

- #### xfsdump
		//進行檔案系統的完整備份 (full backup) 之外，進行累積備份 (Incremental backup)
		-L  ：xfsdump 會紀錄每次備份的 session 標頭，這裡可以填寫針對此檔案系統的簡易說明
		-M  ：xfsdump 可以紀錄儲存媒體的標頭，這裡可以填寫此媒體的簡易說明
		-l  ：是 L 的小寫，就是指定等級～有 0~9 共 10 個等級喔！ (預設為 0，即完整備份)
		-f  ：有點類似 tar 啦！後面接產生的檔案，亦可接例如 /dev/st0 裝置檔名或其他一般檔案檔名等
		-I  ：從 /var/lib/xfsdump/inventory 列出目前備份的資訊狀態

- #### cpio
		備份會使用到的選項與參數：
		  -o ：將資料 copy 輸出到檔案或裝置上
		  -B ：讓預設的 Blocks 可以增加至 5120 bytes ，預設是 512 bytes ！
		　  　 這樣的好處是可以讓大檔案的儲存速度加快(請參考 i-nodes 的觀念)
		還原會使用到的選項與參數：
		  -i ：將資料自檔案或裝置 copy 出來系統當中
		  -d ：自動建立目錄！使用 cpio 所備份的資料內容不見得會在同一層目錄中，因此我們
			   必須要讓 cpio 在還原時可以建立新目錄，此時就得要 -d 選項的幫助！
		  -u ：自動的將較新的檔案覆蓋較舊的檔案！
		  -t ：需配合 -i 選項，可用在"察看"以 cpio 建立的檔案或裝置的內容
		一些可共用的選項與參數：
		  -v ：讓儲存的過程中檔案名稱可以在螢幕上顯示
		  -c ：一種較新的 portable format 方式儲存
	##### Example
	```bash
	cpio -ovcB  > [file|device] <==備份
	cpio -ivcdu < [file|device] <==還原
	cpio -ivct  < [file|device] <==察看
	```

## CH10 認識與學習BASH
### Wildcard
	*	代表『 0 個到無窮多個』任意字元
	?	代表『一定有一個』任意字元
	[ ]	同樣代表『一定有一個在括號內』的字元(非任意字元)。例如 [abcd] 代表『一定有一個字元， 可能是 a, b, c, d 這四個任何一個』
	[ - ]	若有減號在中括號內時，代表『在編碼順序內的所有字元』。例如 [0-9] 代表 0 到 9 之間的所有數字，因為數字的語系編碼是連續的！
	[^ ]	若中括號內的第一個字元為指數符號 (^) ，那表示『反向選擇』，例如 [^abc] 代表 一定有一個字元，只要是非 a, b, c 的其他字元就接受的意思。

### Variables
```bash
	${variable#/*local/bin:} (from left)
	${variable##/*local/bin:}
	${variable%/*local/bin:} (from right)
	${variable%%/*local/bin:}
	${variable/oldstring/newstring}
	new_var=${old_var-content}
	new_var=${old_var:-content}
	man 7 glob /wildcard
```

### Commands
- #### declare [-aixr] variable
		-a  ：將後面名為 variable 的變數定義成為陣列 (array) 類型
		-i  ：將後面名為 variable 的變數定義成為整數數字 (integer) 類型
		-x  ：用法與 export 一樣，就是將後面的 variable 變成環境變數；
		-r  ：將變數設定成為 readonly 類型，該變數不可被更改內容，也不能 unset

- #### cut
		-d  ：後面接分隔字元。與 -f 一起使用；
		-f  ：依據 -d 的分隔字元將一段訊息分割成為數段，用 -f 取出第幾段的意思；
		-c  ：以字元 (characters) 的單位取出固定字元區間；
	##### Example
	```bash
	cut -d ":" -f filename
	```

- #### sort -k 3(column)
		-f  ：忽略大小寫的差異，例如 A 與 a 視為編碼相同；
		-b  ：忽略最前面的空白字元部分；
		-M  ：以月份的名字來排序，例如 JAN, DEC 等等的排序方法；
		-n  ：使用『純數字』進行排序(預設是以文字型態來排序的)；
		-r  ：反向排序；
		-u  ：就是 uniq ，相同的資料中，僅出現一行代表；
		-t  ：分隔符號，預設是用 [tab] 鍵來分隔；
		-k  ：以那個區間 (field) 來進行排序的意思

- #### tee
	##### Example
	```bash
	ls -l /home | tee ~/homefile | more
	```
- #### tr
	##### Example
	```bash
	last | tr '[a-z]' '[A-Z]'
	cat /etc/passwd | tr -d ':'
	```

- #### paste

- #### join

- #### split -bl

- #### xargs
	##### Example
	```bash
	cut -d ':' -f 1 /etc/passwd/head -n 3 | xargs -p -n 1 id
	```

## CH11 Regular Expression
### Commands
- #### grep
	##### Example
	```bash
	grep -n 'go\{2,10\}g' regular_express.txt
	grep -n 'o\{2,10\}g' regular_express.txt
	grep -n 'o\{2,\}g' regular_express.txt
	grep -n 'o\{2,\}o' regular_express.txt
	grep -n 'o\{2,5\}o' regular_express.txt
	grep -n 'g.*g' regular_express.txt
	grep -n 'goo*gle' regular_express.txt
	grep -n 'ood*' regular_express.txt
	grep -n 'ooo*' regular_express.txt
	grep -n '^$' regular_express.txt
	grep -m
	grep -n '\.$' regular_express.txt
	grep -n '...a' regular_express.txt
	grep -n '*a' regular_express.txt
	grep -n '.a' regular_express.txt
	grep -n '^[^[:alpha:]]' regular_express.txt
	grep -n '^[[:lower:]]' regular_express.txt
	grep -n '^[[:alpha:]]' regular_express.txt
	grep -n '^the' regular_express.txt
	grep -n 's[[:blank:]][[:alpha:]]' regular_express.txt
	grep -n 's[[:blank:]][[:digit:]]' regular_express.txt
	grep -n 's[[:blank:][:digit:]]' regular_express.txt
	grep -n '[[:digit:]]' regular_express.txt
	grep -n 's[[:blank:]][:digit:]' regular_express.txt
	grep -n '[^a-z]oo' regular_express.txt
	grep -n '[^g]oo' regular_express.txt
	grep -n '[^g]oo'
	grep -n
	grep -n 'oo' regular_express.txt
	grep -n 't[a-z]st' regular_express.txt
	grep -n 't[/.]st' regular_express.txt
	grep -n 't[\.]st' regular_express.txt
	grep -n 't[.]st' regular_express.txt
	grep -n 't[?]st' regular_express.txt
	grep -n 't[ae]st' regular_express.txt
	grep -n 't[]st' regular_express.txt
	grep -n 't?st' regular_express.txt
	grep -in 'the' regular_express.txt
	grep -vn 'the' regular_express.txt
	grep -n 'the' regular_express.txt
	grep -C 5 # before and after 5 lines
	```

- #### sed
		-n  ：使用安靜(silent)模式。在一般 sed 的用法中，所有來自 STDIN 的資料一般都會被列出到螢幕上。但如果加上 -n 參數後，則只有經過 sed 特殊處理的那一行(或者動作)才會被列出來。
		-e  ：直接在指令列模式上進行 sed 的動作編輯；
		-f  ：直接將 sed 的動作寫在一個檔案內， -f filename 則可以執行 filename 內的 sed 動作；
		-r  ：sed 的動作支援的是延伸型正規表示法的語法。(預設是基礎正規表示法語法)
		-i  ：直接修改讀取的檔案內容，而不是由螢幕輸出。
		a   ：新增， a 的後面可以接字串，而這些字串會在新的一行出現(目前的下一行)～
		c   ：取代， c 的後面可以接字串，這些字串可以取代 n1,n2 之間的行！
		d   ：刪除，因為是刪除啊，所以 d 後面通常不接任何咚咚；
		i   ：插入， i 的後面可以接字串，而這些字串會在新的一行出現(目前的上一行)；
		p   ：列印，亦即將某個選擇的資料印出。通常 p 會與參數 sed -n 一起運作～
		s   ：取代，可以直接進行取代的工作哩！通常這個 s 的動作可以搭配正規表示法！
	##### Example
	```bash
	nl /etc/passwd | sed '2,5d'
	nl /etc/passwd | sed '2a drink tea'
	nl /etc/passwd | sed '2c drink tea'
	ifconfig eth0 | grep 'inet' | sed 's/^.*inet//g' | sed 's/netmask.*$//g'
	# append line after target_string
	sed '/target_string/a string' file_name
	# backup file
	sed -i.bkp '/target_string/a string' file_name
	# insert line before target_string
	sed '/target_string/i string' file_name
	```

- #### printf
		關於格式方面的幾個特殊樣式：
		\a    警告聲音輸出
		\b    倒退鍵(backspace)
		\f    清除螢幕 (form feed)
		\n    輸出新的一行
		\r    亦即 Enter 按鍵
		\t    水平的 [tab] 按鍵
		\v    垂直的 [tab] 按鍵
		\xNN  NN 為兩位數的數字，可以轉換數字成為字元。
		關於 C 程式語言內，常見的變數格式
		%ns   那個 n 是數字， s 代表 string ，亦即多少個字元；
		%ni   那個 n 是數字， i 代表 integer ，亦即多少整數位數；
		%N.nf 那個 n 與 N 都是數字， f 代表 floating (浮點)，如果有小數位數，
		假設我共要十個位數，但小數點有兩位，即為 %10.2f 囉！
	##### Example
	```bash
	printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt | grep -v Name)
	```

- #### awk
		NF每一行 ($0) 擁有的欄位總數
		NR前 awk 所處理的是『第幾行』資料
		FS前的分隔字元，預設是空白鍵
	##### Example
	```bash
	cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'
	cat pay.txt | awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }'
	cat payment.txt | awk 'NR==1 {print ,$1, $2, $3, $4, "total"}'
	cat payment.txt | awk 'NR==1 {print $1, $2, $3, $4, "total"} /
		NR >= 2 {total =  $2+$3+$4 print $1, $2, $3, $4, total}'
	```

- #### cmp
- #### diff

- #### patch
	##### Example
	```bash
	diff -Naur passwd.old passwd.new > passwd.patch
	patch -pN < patch_file    <==更新
	patch -R -pN < patch_file <==還原
	```

## CH12 Script
	/home/ieni/Documents/Vbird/vbird/script

### Commands
- #### test
	##### Example
	```bash
	test -e /dmtsai && echo "exist" || echo "Not exist"
	man test // see the operations

	[ -z "${HOME}"  ] ; echo $?
	[ "${yn}" == "Y" -o "${yn}" == "y"  ]
	[ "${yn}" == "Y"  ] || [ "${yn}" == "y"  ]
	```
### Bash Syntax
- #### if
```bash
if [ 條件判斷式  ]; then
	當條件判斷式成立時，可以進行的指令工作內容；
fi   <==將 if 反過來寫，就成為 fi 啦！結束 if 之意！

if [ 條件判斷式一  ]; then
	當條件判斷式一成立時，可以進行的指令工作內容；
elif [ 條件判斷式二  ]; then
	當條件判斷式二成立時，可以進行的指令工作內容；
else
	當條件判斷式一與二均不成立時，可以進行的指令工作內容；
fi

if [ "${date_total_s}" -lt "0" ]; then                 # 判斷是否已退伍
	echo "You had been demobilization before: " $((-1*${date_d})) " ago"
else
	declare -i date_h=$(($((${date_total_s}-${date_d}*60*60*24))/60/60))
	echo "You will demobilize after ${date_d} days and ${date_h} hours."
fi
```

- #### case
```bash
case  $變數名稱 in   <==關鍵字為 case ，還有變數前有錢字號
	"第一個變數內容")   <==每個變數內容建議用雙引號括起來，關鍵字則為小括號 )
	程式段
	;;            <==每個類別結尾使用兩個連續的分號來處理！
"第二個變數內容")
	程式段
	;;
*)                  <==最後一個變數內容都會用 * 來代表所有其他值
	不包含第一個變數內容與第二個變數內容的其他程式執行段
	exit 1
	;;
esac                  <==最終的 case 結尾！『反過來寫』思考一下！
```
- #### function
```bash
function fname() {
	程式段
}

function printit(){
	echo -n "Your choice is "     # 加上 -n 可以不斷行繼續在同一行顯示
}

```
- #### while
```bash
while [ condition ]  <==中括號內的狀態就是判斷式
do            <==do 是迴圈的開始！
	程式段落
done          <==done 是迴圈的結束

while [ "${i}" != "100" ]
do
	i=$(($i+1))   # 每次 i 都會增加 1
	s=$(($s+$i))  # 每次都會加總一次！
done
```

- #### until
```bash
until [ condition ]
do
	程式段落
done
```
- #### for
```bash
for var in con1 con2 con3 ...
do
	程式段
done

for animal in dog cat elephant
do
	echo "There are ${animal}s.... "
done

for (( 初始值; 限制值; 執行步階 ))
do
	程式段
done

for (( i=1; i<=${nu}; i=i+1 ))
do
	s=$((${s}+${i}))
done
```

## CH13 Linux 帳號管理與 ACL 權限設定
### Commands
- #### id
- #### finger
- #### write
- #### mesg

- #### chage
		-l ：列出該帳號的詳細密碼參數；
		-d ：後面接日期，修改 shadow 第三欄位(最近一次更改密碼的日期)，格式 YYYY-MM-DD
		-E ：後面接日期，修改 shadow 第八欄位(帳號失效日)，格式 YYYY-MM-DD
		-I ：後面接天數，修改 shadow 第七欄位(密碼失效日期)
		-m ：後面接天數，修改 shadow 第四欄位(密碼最短保留天數)
		-M ：後面接天數，修改 shadow 第五欄位(密碼多久需要進行變更)
		-W ：後面接天數，修改 shadow 第六欄位(密碼過期前警告日期)

- #### setfacl
		-m ：設定後續的 acl 參數給檔案使用，不可與 -x 合用；
		-x ：刪除後續的 acl 參數，不可與 -m 合用；
		-b ：移除『所有的』 ACL 設定參數；
		-k ：移除『預設的』 ACL 參數，關於所謂的『預設』參數於後續範例中介紹；
		-R ：遞迴設定 acl ，亦即包括次目錄都會被設定起來；
		-d ：設定『預設 acl 參數』的意思！只對目錄有效，在該目錄新建的資料會引用此預設值
	##### Example
	```bash
	setfacl -m u:vbird:rx acl_test
	```

- #### getfacl acl_test

## CH15 例行性工作排程(crontab)
### Commands
- #### at
	##### Example
	```bash
	at now + 5 min
	at -c 10
	at 23:00 2017-08-07
	atq
	atrm (job number)
	```

- #### crontab
		*(星號)星號代表任何時刻都接受的意思！舉例來說，範例一內那個日、月、週都是 * ， 就代表著『不論何月、何日的禮拜幾的 12:00 都執行後續指令』的意思！
		,(逗號)逗號代表分隔時段的意思。舉例來說，如果要下達的工作是 3:00 與 6:00 時，就會是：
		0 3,6 * * * command
		時間參數還是有五欄，不過第二欄是 3,6 ，代表 3 與 6 都適用！
		-(減號)減號代表一段時間範圍內，舉例來說， 8 點到 12 點之間的每小時的 20 分都進行一項工作：
		20 8-12 * * * command
		仔細看到第二欄變成 8-12 喔！代表 8,9,10,11,12 都適用的意思！
		/n(斜線)斜線那個 n 代表數字，亦即是『每隔 n 單位間隔』的意思，例如每五分鐘進行一次，則：
		*/5 * * * * command
		很簡單吧！用 * 與 /5 來搭配，也可以寫成 0-59/5 ，相同意思！
	##### Example
	```bash
	notify-send for cron: eval "export $(egrep -z DBUS_SESSION_BUS_ADDRESS /proc/$(pgrep -u $LOGNAME gnome-session)/environ)";
	crontab -e // execute
	crontab -l // list
	```
- #### acacrontab

## CH16 程序管理與 SELinux 初探
### Commands
- #### job
- #### fg
- #### bg
- #### nohup
- #### ps
	##### Example
	```bash
	ps aux
	ps axjf //tree
	echo $$ // bash PID
	```

- #### top
		? ：顯示在 top 當中可以輸入的按鍵指令
		P ：以 CPU 的使用資源排序顯示；
		M ：以 Memory 的使用資源排序顯示；
		N ：以 PID 來排序喔！
		T ：由該 Process 使用的 CPU 時間累積 (TIME+) 排序。
		k ：給予某個 PID 一個訊號  (signal)
		r ：給予某個 PID 重新制訂一個 nice 值。
		q ：離開 top 軟體的按鍵。

- #### kill
		-l  ：這個是 L 的小寫，列出目前 kill 能夠使用的訊號 (signal) 有哪些？
		signal ：代表給予後面接的那個工作什麼樣的指示囉！用 man 7 signal 可知：
		-1 ：重新讀取一次參數的設定檔 (類似 reload)；
		-2 ：代表與由鍵盤輸入 [ctrl]-c 同樣的動作；
		-9 ：立刻強制刪除一個工作；
		-15：以正常的程序方式終止一項工作。與 -9 是不一樣的。
	##### Example
	```bash
	kill -l / man 7 signal
	kill -SIGHUP $(ps aux | grep 'rsyslogd' | grep -v 'grep'| awk '{print $2}')
	```

- #### nice [-n 數字] command
- #### renice [number] PID
- #### free [-b|-k|-m|-g|-h] [-t] [-s N -c N]

- #### uname [-asrmpi]
		-a  ：所有系統相關的資訊，包括底下的資料都會被列出來；
		-s  ：系統核心名稱
		-r  ：核心的版本
		-m  ：本系統的硬體名稱，例如 i686 或 x86_64 等；
		-p  ：CPU 的類型，與 -m 類似，只是顯示的是 CPU 的類型！
		-i  ：硬體的平台 (ix86)

- #### netstat -[atunlp]
		-a  ：將目前系統上所有的連線、監聽、Socket 資料都列出來
		-t  ：列出 tcp 網路封包的資料
		-u  ：列出 udp 網路封包的資料
		-n  ：不以程序的服務名稱，以埠號 (port number) 來顯示；
		-l  ：列出目前正在網路監聽 (listen) 的服務；
		-p  ：列出該網路服務的程序 PID

- #### dmesg

- #### vmstat
		vmstat [-a] [延遲 [總計偵測次數]] =CPU/記憶體等資訊
		vmstat [-fs]                      =記憶體相關
		vmstat [-S 單位]                  =設定顯示數據的單位
		vmstat [-d]                       =與磁碟有關
		vmstat [-p 分割槽]                =與磁碟有關
			-a  ：使用 inactive/active(活躍與否) 取代 buffer/cache 的記憶體輸出資訊；
			-f  ：開機到目前為止，系統複製 (fork) 的程序數；
			-s  ：將一些事件 (開機至目前為止) 導致的記憶體變化情況列表說明；
			-S  ：後面可以接單位，讓顯示的資料有單位。例如 K/M 取代 bytes 的容量；
			-d  ：列出磁碟的讀寫總量統計表
			-p  ：後面列出分割槽，可顯示該分割槽的讀寫總量統計表

- #### fuser [-umv] [-k [i] [-signal]] file/dir
		-u  ：除了程序的 PID 之外，同時列出該程序的擁有者；
		-m  ：後面接的那個檔名會主動的上提到該檔案系統的最頂層，對 umount 不成功很有效！
		-v  ：可以列出每個檔案與程序還有指令的完整相關性！
		-k  ：找出使用該檔案/目錄的 PID ，並試圖以 SIGKILL 這個訊號給予該 PID；
		-i  ：必須與 -k 配合，在刪除 PID 之前會先詢問使用者意願！
		-signal：例如 -1 -15 等等，若不加的話，預設是 SIGKILL (-9) 囉！
			ACCESS:
			c ：此程序在當前的目錄下(非次目錄)；
			e ：可被觸發為執行狀態；
			f ：是一個被開啟的檔案；
			r ：代表頂層目錄 (root directory)；
			F ：該檔案被開啟了，不過在等待回應中；
			m ：可能為分享的動態函式庫；

- #### lsof [-aUu] [+d]
		-a  ：多項資料需要『同時成立』才顯示出結果時！
		-U  ：僅列出 Unix like 系統的 socket 檔案類型；
		-u  ：後面接 username，列出該使用者相關程序所開啟的檔案；
		+d  ：後面接目錄，亦即找出某個目錄底下已經被開啟的檔案！

##  CH17 認識系統服務 (daemons)
### Services
	syslog	這個是 Linux 核心所提供的登錄檔設計指引，所有的要求大概都寫入道一個名為 syslog.h 的標頭檔案中。如果你想要開發與登錄檔有關的軟體， 那你就得要依循這個 syslog 函數的要求去設計才行！可以使用 man 3 syslog 去查詢一下相關的資料！
	rsyslogd	為了要達成實際上進行訊息的分類所開發的一套軟體，所以，這就是最基本的 daemon 程式！
	rsyslog.service	為了加入 systemd 的控制，因此 rsyslogd 的開發者設計的啟動服務腳本設定
### Commands
- #### systemctl [command] [unit]
		command 主要有：
		start     ：立刻啟動後面接的 unit
		stop      ：立刻關閉後面接的 unit
		restart   ：立刻關閉後啟動後面接的 unit，亦即執行 stop 再 start 的意思
		reload    ：不關閉後面接的 unit 的情況下，重新載入設定檔，讓設定生效
		enable    ：設定下次開機時，後面接的 unit 會被啟動
		disable   ：設定下次開機時，後面接的 unit 不會被啟動 //從 /etc/systemd/system 底下刪除一條連結檔案
		status    ：目前後面接的這個 unit 的狀態，會列出有沒有正在執行、開機預設執行否、登錄等資訊等！
		is-active ：目前有沒有正在運作中
		is-enabled：開機時有沒有預設要啟用這個 unit
		command:
		list-units      ：依據 unit 列出目前有啟動的 unit。若加上 --all 才會列出沒啟動的。
		list-unit-files ：依據 /usr/lib/systemd/system/ 內的檔案，將所有檔案列表說明。
		--type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等
	##### Example
	```bash
	systemctl mask cups.service
	systemctl unmask cups.service

	systemctl poweroff  系統關機
	systemctl reboot    重新開機
	systemctl suspend   進入暫停模式
		suspend：暫停模式會將系統的狀態資料保存到記憶體中，然後關閉掉大部分的系統硬體，當然，並沒有實際關機喔！ 當使用者按下喚醒機器的按鈕，系統資料會重記憶體中回復，然後重新驅動被大部分關閉的硬體，就開始正常運作！喚醒的速度較快。
	systemctl hibernate 進入休眠模式
		hibernate：休眠模式則是將系統狀態保存到硬碟當中，保存完畢後，將電腦關機。當使用者嘗試喚醒系統時，系統會開始正常運作， 然後將保存在硬碟中的系統狀態恢復回來。因為資料是由硬碟讀出，因此喚醒的效能與你的硬碟速度有關。
	systemctl rescue    強制進入救援模式
	systemctl emergency 強制進入緊急救援模式

	systemctl list-dependencies
	systemctl list-dependencies --reverse

	cat /etc/services
	man systemd.timer # option for timer units
	man systemd.time # time format
	```

## CH18 認識與分析登錄檔
### Log
	```bash
	/var/log/syslog
	/var/log/auth.log //login infomation
	log manager: systemd-journald.service  rsyslog.service
	/etc/rsyslog.conf  /etc/rsyslog.d/ # rsyslog config file
	```

### Commands
- #### logrotate [-vf] logfile
		選項與參數：
		-v  ：啟動顯示模式，會顯示 logrotate 運作的過程喔！
		-f  ：不論是否符合設定檔的資料，強制每個登錄檔都進行 rotate 的動作！

- #### journalctl [-nrpf] [--since TIME] [--until TIME] optional
		預設會秀出全部的 log 內容，從舊的輸出到最新的訊息
		-n  ：秀出最近的幾行的意思～找最新的資訊相當有用
		-r  ：反向輸出，從最新的輸出到最舊的資料
		-p  ：秀出後面所接的訊息重要性排序！請參考前一小節的 rsyslogd 資訊
		-f  ：類似 tail -f 的功能，持續顯示 journal 日誌的內容(即時監測時相當有幫助！)
		--since --until：設定開始與結束的時間，讓在該期間的資料輸出而已
		SYSTEMD_UNIT=unit.service ：只輸出 unit.service 的資訊而已
		COMM=bash ：只輸出與 bash 有關的資訊
		PID=pid   ：只輸出 PID 號碼的資訊
		UID=uid   ：只輸出 UID 為 uid 的資訊
		SYSLOG_FACILITY=[0-23] ：使用 syslog.h 規範的服務相對序號來呼叫出正確的資料！
	##### Example
	```bash
	journalctl --since "2015-08-18 00:00:00" --until "2015-08-19 00:00:00"
	journalctl --since today
	journalctl --since yesterday --until today
	journalctl _SYSTEMD_UNIT=crond.service -n 10
	```
- #### logger
- #### logwatch  /etc/cron.daily

## CH20 開機流程、模組管理與 Loader
### 開機
系統開機的經過可以彙整成底下的流程的：BIOS -> MBR -> boot loader -> kernel -> systemd
1. 載入 BIOS 的硬體資訊與進行自我測試，並依據設定取得第一個可開機的裝置；
2. 讀取並執行第一個開機裝置內 MBR 的 boot Loader (亦即是 grub2, spfdisk 等程式)；
3. 依據 boot loader 的設定載入 Kernel ，Kernel 會開始偵測硬體與載入驅動程式；
4. 在硬體驅動成功後，Kernel 會主動呼叫 systemd 程式，並以 default.target 流程開機；
	- systemd 執行 sysinit.target 初始化系統及 basic.target 準備作業系統；
	- systemd 啟動 multi-user.target 下的本機與伺服器服務；
	- systemd 執行 multi-user.target 下的 /etc/rc.d/rc.local 檔案；
	- systemd 執行 multi-user.target 下的 getty.target 及登入服務；
	- systemd 執行 graphical 需要的服務

systemd 開機流程大約是這樣： # systemctl list-dependencies graphical.target
	local-fs.target + swap.target：這兩個 target 主要在掛載本機 /etc/fstab 裡面所規範的檔案系統與相關的記憶體置換空間。
	sysinit.target：這個 target 主要在偵測硬體，載入所需要的核心模組等動作。
	basic.target：載入主要的週邊硬體驅動程式與防火牆相關任務
	multi-user.target 底下的其它一般系統或網路服務的載入
	圖形界面相關服務如 gdm.service 等其他服務的載入


#### Example of initrd
```bash
man initrd # initial RAM Disk

# using initrd
mkdir /dev/shm/initramfs
cd /dev/shm/initramfs
cpio -i -d --no-absolute-filenames -I /boot/initrdfilename #get block number
dd if=/boot/initramfs-3.10.0-229.el7.x86_64.img of=initramfs.gz  bs=blocknum*512 skip=1
ll initramfs.gz; file initramfs.gz
gzip -d initramfs.gz
file initramfsu
cpio -i -d -H newc --no-absolute-filenames < initramfs
ll usr/lib/systemd/system/default.target

man runlevel # replace runlevel with target
/lib/systemd/system # target files

uname -r == /proc/version   #kenel version
lsb_release #ubuntu version
```

### Commmands
- ####  /lib/modules/$(uname -r)/kernel  # kernel modules
		arch	：與硬體平台有關的項目，例如 CPU 的等級等等；
		crypto	：核心所支援的加密的技術，例如 md5 或者是 des 等等；
		drivers	：一些硬體的驅動程式，例如顯示卡、網路卡、PCI 相關硬體等等；
		fs	：核心所支援的 filesystems ，例如 vfat, reiserfs, nfs 等等；
		lib	：一些函式庫；
		net	：與網路有關的各項協定資料，還有防火牆模組 (net/ipv4/netfilter/*) 等等；
		sound	：與音效有關的各項模組；
	##### Example
	```bash
	find /lib/modules/$(uname -r) -type f -name '*.ko'
	```

- #### depmod [-Ane]
		-A  ：不加任何參數時， depmod 會主動的去分析目前核心的模組，並且重新寫入
			  /lib/modules/$(uname -r)/modules.dep 當中。若加入 -A 參數時，則 depmod
			  會去搜尋比 modules.dep 內還要新的模組，如果真找到新模組，才會更新。
		-n  ：不寫入 modules.dep ，而是將結果輸出到螢幕上(standard out)；
		-e  ：顯示出目前已載入的不可執行的模組名稱

- #### lsmod
		show all the kernel modules

- #### modinfo [-F field] [-adln] [module_name|filename]
		# show kernel module infomation
		-F  ：僅列出後面所接的欄位，欄位內容主要有 author(作者), description(描述),
			  license(授權), parm(參數), depends(相依性), alias等等。後續的 -adln 為舊版相容。
		-a  ：僅列出作者名稱；
		-d  ：僅列出該 modules 的說明 (description)；
		-l  ：僅列出授權 (license)；
		-n  ：僅列出該模組的詳細路徑。

- #### insmod
		# load module
- #### rmmod
		# remove module

- #### modprobe [-cfr] module_name
		-c  ：列出目前系統所有的模組！(更詳細的代號對應表)
		-f  ：強制載入該模組；
		-r  ：類似 rmmod ，就是移除某個模組囉～
		-b  : blacklist  # /etc/modprobe.d/blacklist.conf
	##### Example
	```bash
	modprobe -r uvcvideo
	modprobe -a uvcvideo
	# test with cheese
	```

- #### grub-install --version

- #### dracut [-fv] [--add-drivers 列表] initramfs檔名 核心版本
		-f   ：強迫編譯出 initramfs ，如果 initramfs 檔案已經存在，則覆蓋掉舊檔案
		-v   ：顯示 dracut 的運作過程
		--add-drivers 列表：在原本的預設核心模組中，增加某些你想要的模組！模組位於核心所在目錄
							/lib/modules/$(uname -r)/kernel/*
		initramfs檔名     ：就是你需要的檔名！開頭最好就是 initramfs，後面接版本與功能
		核心版本          ：預設當然是目前運作中的核心版本，不過你也可以手動輸入其他不同版本！
		其實 dracut 還有很多功能，例如底下的幾個參數也可以參考看看：
		--modules  ：將 dracut 所提供的開機所需模組 (核心核模組) 載入，可用模組在底下的目錄內
					 /usr/lib/dracut/modules.d/
		--gzip|--bzip2|--xz：嘗試使用哪一種壓縮方式來進行 initramfs 壓縮。預設使用 gzip 喔！
		--filesystems ：加入某些額外的檔案系統支援！
	##### Example
	```bash
	dracut -v initramfs-test.img $(uname -r)
	dracut -v --add-drivers "e1000e" --filesystems "ext4 nfs" initramfs-new.img $(uname -r)
	```

## CH20 基礎系統設定與備份策略
### Commands
- #### nmcli
	##### Example
	```bash
	nmcli d wifi # scan
	nmcli c show # remembered wifi connection

	nmcli d connect [interface]
	nmcli c up uuid cd79a7a1-1cf4-49c3-ad58-21ab17d1ba05
	nmcli c up id Rishbh-Q1000
	nmcli c up id Rishbh-Q1000 iface wlan1 # specific interface
	nmcli d wifi connect "SSID" password "password"

	nmcli d disconnect [interface]
	nmcli c down id Rishbh-Q1000
	nmcli c down uuid cd79a7a1-1cf4-49c3-ad58-21ab17d1ba05

	[reference](https://askubuntu.com/questions/377687/how-do-i-connect-to-a-wifi-network-using-nmcli)

	nmcli connection modify eth0 \
		  connection.autoconnect yes \
		  ipv4.method manual \
		  ipv4.addresses 172.16.1.1/16 \
		  ipv4.gateway 172.16.200.254 \
		  ipv4.dns 172.16.200.254
	nmcli connection up eth0

	nmcli connection modify eth0 \
		  connection.autoconnect yes \
		  ipv4.method auto
	```

- #### hostnamectl [set-hostname 你的主機名]

- #### timedatectl [commamd]
		list-timezones ：列出系統上所有支援的時區名稱
		set-timezone   ：設定時區位置
		set-time       ：設定時間
		set-ntp        ：設定網路校時系統
	##### Example
	```bash
	timedatectl list-timezones | grep -i tonga
	timedatectl set-timezone "Asia/Taipei"
	timedatectl list-timezones
	timedatectl set-time "2015-09-01 12:02"
	```

- #### localectl
	##### Example
	```bash
	localectl set-locale LANG=en_US.utf8
	```

- #### dmidecode -t type
		詳細的 type 項目請 man dmidecode 查詢更多的資料，這裡僅列出比較常用的項目：
		1 ：詳細的系統資料，含主機板的型號與硬體的基礎資料等
		4 ：CPU 的相關資料，包括倍頻、外頻、核心數、核心緒數等
		9 ：系統的相關插槽格式，包括 PCI, PCI-E 等等的插槽規格說明
		17：每一個記憶體插槽的規格，若內有記憶體，則列出該記憶體的容量與型號

- #### lspci [-vvn]
		-v  ：顯示更多的 PCI 介面裝置的詳細資訊；
		-vv ：比 -v 還要更詳細的細部資訊；
		-n  ：直接觀察 PCI 的 ID 而不是廠商名稱

- #### lsusb [-t]
		-t  ：使用類似樹狀目錄來顯示各個 USB 埠口的相關性

- #### iostat [-c|-d] [-k|-m] [-t] [間隔秒數] [偵測次數]
		-c  ：僅顯示 CPU 的狀態；
		-d  ：僅顯示儲存設備的狀態，不可與 -c 一起用；
		-k  ：預設顯示的是 block ，這裡可以改成 K bytes 的大小來顯示；
		-m  ：與 -k 類似，只是以 MB 的單位來顯示結果。
		-t  ：顯示日期出來；

- #### smartctl
	##### Example
	```bash
	smartctl -a /dev/sda 	#show disk
	smartctl -t short /dev/sda #test disk
	```

## CH21 軟體安裝：原始碼與 Tarball
### Tarball
Tarball 安裝的基本步驟
1. 取得原始檔：將 tarball 檔案在 /usr/local/src 目錄下解壓縮；
2. 取得步驟流程：進入新建立的目錄底下，去查閱 INSTALL 與 README 等相關檔案內容 (很重要的步驟！)；
3. 相依屬性軟體安裝：根據 INSTALL/README 的內容察看並安裝好一些相依的軟體 (非必要)；建立 makefile：以自動偵測程式 (configure 或 config) 偵測作業環境，並建立 Makefile 這個檔案；
4. 編譯：以 make 這個程式並使用該目錄下的 Makefile 做為他的參數設定檔，來進行 make (編譯或其他) 的動作；
5. 安裝：以 make 這個程式，並以 Makefile 這個參數設定檔，依據 install 這個標的 (target) 的指定來安裝到正確的路徑！

#### Example
```bash
cd /usr/local/src
tar -jxvp -f tarfile
cd tarfile
./configure --help | less
./configure --prefix=targetpath
make clean; make; make check; make install
# 自己安裝的軟體放置在 /usr/local 下，至於原始碼 (Tarball)則建議放置在 /usr/local/src (src 為 source 的縮寫)
```

### Commands
- #### gcc
	##### Example
	```bash
	gcc -c thanks.c thanks_2.c
	gcc -o thanks thanks.o thanks_2.o
	gcc sin.c -lm -L/lib -L/lib64
		# -l ：是『加入某個函式庫(library)』的意思，
		# -m ：則是 libm.so 這個函式庫，其中， lib 與副檔名(.a 或 .so)不需要寫
	```

- #### ldconfig [-f conf] [ -C cache]
		ldconfig [-p]
		-f conf ：那個 conf 指的是某個檔案名稱，也就是說，使用 conf 作為 libarary
			  函式庫的取得路徑，而不以 /etc/ld.so.conf 為預設值
		-C cache：那個 cache 指的是某個檔案名稱，也就是說，使用 cache 作為快取暫存
			  的函式庫資料，而不以 /etc/ld.so.cache 為預設值
		-p	：列出目前有的所有函式庫資料內容 (在 /etc/ld.so.cache 內的資料！)

- #### ldd [-vdr] [filename]
		-v ：列出所有內容資訊；
		-d ：重新將資料有遺失的 link 點秀出來！
		-r ：將 ELF 有關的錯誤內容秀出來！

- #### md5sum/sha1sum/sha256sum [-bct] filename
		md5sum/sha1sum/sha256sum [--status|--warn] --check filename
		-b ：使用 binary 的讀檔方式，預設為 Windows/DOS 檔案型態的讀取方式；
		-c ：檢驗檔案指紋；
		-t ：以文字型態來讀取檔案指紋。

## CH22 Kernel
### Kernel Directory (/usr/src/linux-headers-$(uname -r)/)
		arch ：與硬體平台有關的項目，大部分指的是 CPU 的類別，例如 x86, x86_64, Xen 虛擬支援等；
		block ：與區塊裝置較相關的設定資料，區塊資料通常指的是大量儲存媒體！還包括類似 ext3 等檔案系統的支援是否允許等。
		crypto ：核心所支援的加密的技術，例如 md5 或者是 des 等等；
		Documentation ：與核心有關的一堆說明文件，若對核心有極大的興趣，要瞧瞧這裡！
		drivers ：一些硬體的驅動程式，例如顯示卡、網路卡、PCI 相關硬體等等；
		firmware ：一些舊式硬體的微指令碼 (韌體) 資料；
		fs ：核心所支援的 filesystems ，例如 vfat, reiserfs, nfs 等等；
		include ：一些可讓其他程序呼叫的標頭 (header) 定義資料；
		init ：一些核心初始化的定義功能，包括掛載與 init 程式的呼叫等；
		ipc ：定義 Linux 作業系統內各程序的溝通；
		kernel ：定義核心的程序、核心狀態、執行緒、程序的排程 (schedule)、程序的訊號 (signle) 等
		lib ：一些函式庫；
		mm ：與記憶體單元有關的各項資料，包括 swap 與虛擬記憶體等；
		net ：與網路有關的各項協定資料，還有防火牆模組 (net/ipv4/netfilter/*) 等等；
		security ：包括 selinux 等在內的安全性設定；
		sound ：與音效有關的各項模組；
		virt ：與虛擬化機器有關的資訊，目前核心支援的是 KVM (Kernel base Virtual Machine)

### Commands
- #### make
	##### Example
	```bash
	make menuconfig
		# 最常使用的，是文字模式底下可以顯示類似圖形介面的方式，不需要啟動 X Window 就能夠挑選核心功能選單！
	make oldconfig
		# 透過使用已存在的 ./.config 檔案內容，使用該檔案內的設定值為預設值，只將新版本核心內的新功能選項列出讓使用者選擇， 可以簡化核心功能的挑選過程！對於作為升級核心原始碼後的功能挑選來說，是非常好用的一個項目！
	make xconfig
		# 透過以 Qt 為圖形介面基礎功能的圖形化介面顯示，需要具有 X window 的支援。例如 KDE 就是透過 Qt 來設計的 X Window，因此你如果在 KDE 畫面中，可以使用此一項目。
	make gconfig
		# 透過以 Gtk 為圖形介面基礎功能的圖形化介面顯示，需要具有 X window 的支援。例如 GNOME 就是透過 Gtk 來設計的 X Window，因此你如果在 GNOME 畫面中，可以使用此一項目。
	make config
		# 最舊式的功能挑選方法，每個項目都以條列式一條一條的列出讓你選擇，如果設定錯誤只能夠再次選擇，很不人性化啊！

	make vmlinux  # 未經壓縮的核心
	make modules  # 僅核心模組
	make bzImage  # 經壓縮過的核心(預設)
	make all      # 進行上述的三個動作

	make -j 4 clean    # 先清除暫存檔
	make -j 4 bzImage  # 先編譯核心
	make -j 4 modules  # 再編譯模組
	make -j 4 clean bzImage modules  # 連續動作！
	```

Vbird Server
--
## Ch1 小型雲系統與主機安全強化流程
### Example
```bash
lsblk # show the storage device
dd if=CentOS-7-x86_64-DVD-1708.iso of=/dev/sdc  # make iso
grep vmx /proc/cpuinfo  # check if the cpu supports virtualize cmd

vim /etc/aliases
newaliases #  update /etc/aliases to /etc/aliases.db

logwatch
sh /etc/cron.daily/00logwatch  # analysis log file and mail to root
```

### Commands
- #### nmap [掃瞄類型] [掃瞄參數] [hosts 位址與範圍]
		[掃瞄類型]：主要的掃瞄類型有底下幾種：
			-sT：掃瞄 TCP 封包已建立的連線 connect() ！
			-sS：掃瞄 TCP 封包帶有 SYN 標籤的資料
			-sP：以 ping 的方式進行掃瞄
			-sU：以 UDP 的封包格式進行掃瞄
			-sO：以 IP 的協定 (protocol) 進行主機的掃瞄
		[掃瞄參數]：主要的掃瞄參數有幾種：
			-PT：使用 TCP 裡頭的 ping 的方式來進行掃瞄，可以獲知目前有幾部電腦存活(較常用)
			-PI：使用實際的 ping (帶有 ICMP 封包的) 來進行掃瞄
			-p ：這個是 port range ，例如 1024-, 80-1023, 30000-60000 等等的使用方式
			-TN：指定延遲時間，可透過類似 -T4 來加快偵測速度 (約 4ms)，效能會較好。
		[Hosts 位址與範圍]：這個有趣多了，有幾種類似的類型
			192.168.1.100  ：直接寫入 HOST IP 而已，僅檢查一部；
			192.168.1.0/24 ：為 C Class 的型態，
			192.168.*.*　　：嘿嘿！則變為 B Class 的型態了！掃瞄的範圍變廣了！
			192.168.1.0-50,60-100,103,200 ：這種是變形的主機範圍啦！很好用吧！

## CH2 基礎網路概念
### Network
#### 7 Layer
- Layer 1 實體層 Physical Layer
	+ 由於網路媒體只能傳送 0 與 1 這種位元串，因此實體層必須定義所使用的媒體設備之電壓與訊號等， 同時還必須瞭解資料訊框轉成位元串的編碼方式，最後連接實體媒體並傳送/接收位元串。
- Layer 2 資料鏈結層 Data-Link Layer
	+ 這一層是比較特殊的一個階層，因為底下是實體的定義，而上層則是軟體封裝的定義。因此第二層又分兩個子層在進行資料的轉換動作。 在偏硬體媒體部分，主要負責的是 MAC (Media Access Control) ，我們稱這個資料包裹為 MAC 訊框 (frame)， MAC 是網路媒體所能處理的主要資料包裹，這也是最終被實體層編碼成位元串的資料。MAC 必須要經由通訊協定來取得媒體的使用權， 目前最常使用的則是 IEEE 802.3 的乙太網路協定。詳細的 MAC 與乙太網路請參考下節說明。
	+ 至於偏向軟體的部分則是由邏輯連結層 (logical link control, LLC) 所控制，主要在多工處理來自上層的封包資料 (packet) 並轉成 MAC 的格式， 負責的工作包括訊息交換、流量控制、失誤問題的處理等等。
- Layer 3 網路層Network Layer
	+ 這一層是我們最感興趣的囉，因為我們提及的IP (Internet Protocol) 就是在這一層定義的。 同時也定義出電腦之間的連線建立、終止與維持等，資料封包的傳輸路徑選擇等等，因此這個層級當中最重要的除了 IP 之外，就是封包能否到達目的地的路由 (route) 概念了！
- Layer 4 傳送層 Transport Layer
	+ 這一個分層定義了發送端與接收端的連線技術(如 TCP, UDP 技術)， 同時包括該技術的封包格式，資料封包的傳送、流程的控制、傳輸過程的偵測檢查與復原重新傳送等等， 以確保各個資料封包可以正確無誤的到達目的端。
- Layer 5 會談層 Session Layer
	+ 在這個層級當中主要定義了兩個位址之間的連線通道之連接與掛斷，此外，亦可建立應用程式之對談、 提供其他加強型服務如網路管理、簽到簽退、對談之控制等等。如果說傳送層是在判斷資料封包是否可以正確的到達目標， 那麼會談層則是在確定網路服務建立連線的確認。
- Layer 6 表現層  Presentation Layer
	+ 我們在應用程式上面所製作出來的資料格式不一定符合網路傳輸的標準編碼格式的！ 所以，在這個層級當中，主要的動作就是：將來自本地端應用程式的資料格式轉換(或者是重新編碼)成為網路的標準格式， 然後再交給底下傳送層等的協定來進行處理。所以，在這個層級上面主要定義的是網路服務(或程式)之間的資料格式的轉換， 包括資料的加解密也是在這個分層上面處理。
- Layer 7 應用層 Application Layer
	+ 應用層本身並不屬於應用程式所有，而是在定義應用程式如何進入此層的溝通介面，以將資料接收或傳送給應用程式，最終展示給使用者。

#### Ports
		20	FTP-data，檔案傳輸協定所使用的主動資料傳輸埠口
		21	FTP，檔案傳輸協定的命令通道
		22	SSH，較為安全的遠端連線伺服器
		23	Telnet，早期的遠端連線伺服器軟體
		25	SMTP，簡單郵件傳遞協定，用在作為 mail server 的埠口
		53	DNS，用在作為名稱解析的領域名稱伺服器
		80	WWW，這個重要吧！就是全球資訊網伺服器
		110	POP3，郵件收信協定，辦公室用的收信軟體都是透過他
		443	https，有安全加密機制的WWW伺服器

#### 網路重要參數:
		IP
		Netmask
		Network
		Broadcast
		Gateway
		DNS
		閘道器（gateway）能在不同協定間移動資料，而路由器（router）是在不同網路間移動資料，相當於傳統所說的IP閘道器（IP gateway）

### Commands
- #### route [-n]
		-n ： 將主機名稱以 IP 的方式顯示

- #### arp -[nd] hostname
		arp -s hostname(IP) Hardware_address
		-n ：將主機名稱以 IP 的型態顯示
		-d ：將 hostname 的 hardware_address 由 ARP table 當中刪除掉
		-s ：設定某個 IP 或 hostname 的 MAC 到 ARP table 當中
		/etc/resolv.conf -> DNS 主機 IP // Hinet 168.95.1.1

## CH4 連上 Internet
### Network Card
#### Example
```bash
# kernel
dmesg | grep -in eth
# chip
lspci | grep -i ethernet
# module
lsmod | grep 8169
modinfo r8169

# start/shotdown nework
/etc/init.d/network restart
ifup eth0
ifdown eth0
ifconfig eth0 up/down
```
#### 網路相關設定檔案:
- Debian/Ubuntu: /etc/network/interfaces or RedHat: /etc/sysconfig/network-scripts/ifcfg-eth0
	+ ip/netmask/DHCP/Gateway
		* DEVICE=網卡的代號
		* BOOTPROTO=是否使用 dhcp
		* HWADDR=是否加入網卡卡號(MAC)
		* IPADDR=就是IP位址
		* NETMASK=子網路遮罩啦
		* ONBOOT=要不要預設啟動此介面
		* GATEWAY=就是通訊閘啦
		* NM_CONTROLLED=額外的網管軟體 鳥哥建議取消這個項目！
- Debian/Ubuntu: /etc/hostname or RedHat: /etc/sysconfig/network
	+ hostname
- /etc/resolv.conf
	+ DNS IP
- /etc/hosts
	+ /etc/hosts

# Zsh

## Tips
- [Configuring to detect if a command does not exist, suggest installation](https://askubuntu.com/questions/34978/configuring-to-detect-if-a-command-does-not-exist-suggest-installation)
	```
	. /etc/zsh_command_not_found
	```

# Grub
## config
- /etc/default/grub
- /boot/grub/grub.cfg
- sudo update-grub



# Git
## Gitflow
### [Gitflow Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)
### [Gitflow Workflow Github](https://github.com/nvie/gitflow)
```bash
git flow feature start feature_branch
git flow feature finish feature_branch

git flow release start 0.0.1
git checkout master
git checkout merge release/0.1.0
git flow release finish '0.1.0'

git flow hotfix start hotfix_branch
git flow hotfix finish hotfix_branch
```
### Remove a file from a Git repository without deleting it from the local filesystem
```bash
# For single file:
git rm --cached mylogfile.log
# For single directory:
git rm --cached -r mydirectory
```
### Setting bare repository
```bash
git --git-dir=git_file_path --work-tree=git_work_path
```

### [how to set up username and passwords for different git repos ](https://unix.stackexchange.com/questions/335704/how-to-set-up-username-and-passwords-for-different-git-repos)
```bash
# Then the first time you access a repository, git will ask for your password. it will be stored (by default in ~/.git-credentials)
git config credential.${remote}.username yourusername
git config credential.helper store
```

## discard unstaged changes
```bash
git checkout -- .
```

# Docker
- [cannot-connect-to-the-internet-from-your-docker-containers](https://odino.org/cannot-connect-to-the-internet-from-your-docker-containers/)
```
In our case, we realized our firewall was acting pretty weirdly with Google’s public DNSes (8.8.8.8 and 8.8.4.4), which happen to be the default ones Docker is gonna use in case you don’t have anything custom specified in your resolv.conf and so on.
The issue, overall, was quite easy to circumvent, as we just told docker to use OpenDNS in our /etc/default/docker
```
```bash
docker run -it -p 4040:4040 -p 8080:8080 -p 8081:8081 -h spark --name=spark p7hb/docker-spark
docker cp -r spark:/root/hw1/normalized_output.csv
docker cp test.py  spark:/root/hw1/hw1_finish.py
docker container create --name 'vbird' ubuntu
docker exec -it goofy_almeida /bin/bash
```

# Command Tips
```bash
# ascii art
figlet
toilet

# check operation not possible due to rf-kill
iwconfig # not hardware problem
sudo ifconfig wlan1 up
sudo rfkill list # soft blocked: turn off
rfkill unblock wifi
sudo rfkill list

# change mac address
ip link show
ip link set dev [wifi-interface] down
ip link set dev [wifi-interface] address xx:xx:xx:xx:xx:xx
ip link set dev [wifi-interface] up

# curl
## store the outputs as file
curl target_url -o filename
curl target_url > filename

## download multiple files
curl -O file_url1 -O file_url2

## ftp
curl ftp_url --user username:password

## upload file
curl -T upload_file ftp_url --user username:password

## automatically resume the interupted downloading process(ctrl + C)
curl -C - -O url

## sending mail
curl --url "smtp_server_url" --ssl-read --mail-from "sender email" --mail-rcpt "receiver email" --upload-file mailcontent.txt --user "username:password" --insecure

## limit downloadrate
curl --limit-rate 200 -O file_url

## show response header
curl -l url

## proxy
curl -x proxy_host:port taget_url

## ssl
curl -cacert file.crt target_url

curl --header "Content-Type: application/json" \
  --request POST \
  --data '{"username":"xyz","password":"xyz"}' \
  http://localhost:3000/api/login

# COPY
pv my_big_file > backup/my_big_file
rsync -ah --progress source-file destination-file
rsync -azvP

# IP reverse
host IP
dig -x IP
nslookup IP

# system monitor
gtop
watch sensors //CPU
watch nvidia-smi -q -d temperature

# hex2ascii
xxd -p asciifilename
xxd -r -p hexfilename

# Gnome
gsettings get org.gnome.desktop.interface gtk-theme # get the theme name
gsettings set org.gnome.desktop.interface gtk-theme Materia-dark # get the theme name
gsettings get org.gnome.desktop.interface monospace-font-name
gsettings set org.gnome.desktop.interface monospace-font-name Monaco 13

# recursive mkdir
mkdir -p foo/bar/zoo/andsoforth

# apt
/etc/apt/sources.list
/etc/apt/sources.list.d/
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup

# connect to wired connection
sudo dhclient [interface]

# random number range
shuf -i 1-100 -n 1
awk -v min=5 -v max=10 'BEGIN{srand(); print int(min+rand()*(max-min+1))}'

# unblock bluetooth
rfkill list
rfkill unblock bluetooth

# check authentication
journalctl -a


# [xev](https://askubuntu.com/questions/796715/cant-use-volume-keys-but-i-can-use-brightness-keys-on-lubuntu-16-04): test keyboard
# [How to move all files in current folder to subfolder?](https://askubuntu.com/questions/91740/how-to-move-all-files-in-current-folder-to-subfolder)

# gpy memory
gpustat -p | awk 'NR==2 {for (i=15; i <= NF; ++i) print $i}' | cut -d '/' -f 2 | cut -d '(' -f 1 | xargs ps -p

# enable/disable touchpad
xinput ls
xinput --disable [touchpad id]
xinput --enable [touchpad id]

# usb read-only
sudo umount /dev/sdb1
sudo dosfsck -a /dev/sdb1
# maybe you need to change the permission of the mount point
killall nautilus

# redshift
redshift -l 23.9:121 -t 5700:3600 -g 0.8 -m randr -v

# ufw firewall
sudo ufw status
sudo ufw allow [service, port]
sudo ufw reload

# [move /var directory to another partition](https://serverfault.com/questions/429937/how-to-move-var-to-another-existing-partition)
mkdir -p /home/var
rsync -va /var /home/var
mv /var /var.old # you can remove /var.old when you are done to reclaim the space
mkdir -p /var
mount -o bind /home/var /var
# update your /etc/fstab to make the bind-mount permanent.
sudo vim /etc/fstab

/home/var /var  none    defaults,bind 0 0
```


# Installed App
```bash
# english dictionary
npm install -g english-dictionary-cli
definition [word] [option]
	-f : Print related words
	-s : Print sentences
	-d : Print descriptions
	-a : Print everything

#remote desktop
xrdp
sudo systemctl start xrdp
```

# Useful Info
## [Ubuntu grub rescue](https://hk.saowen.com/a/271605ea9c1b15c6f9a2c39f7c210d75ca249c715d18d020db0b17d237acfeef):
```bash
sudo su
sudo add-apt add-apt-repository ppa:yannubuntu/boot-repair
apt-get update
apt-get install boot-repair
# 在dash中搜索boot-repair
# 點recommand repair
# 之後會自動執行

su 　　　　# 獲取root權限
cp /boot/grub/grub.cfg /boot/grub/grub.cfg_backup　　#先備份一下
cat /boot/grub/grub.cfg > tmp　　#將內容重定向到其他文檔，便於修改
gedit tmp　　#或者vim tmp
# 將下面這些內容全部刪掉
## BEGIN /etc/grub.d/25_custom ##
```

## Ubuntu 網路設定
```bash
iwlist, iwconfig # 無線上網指令 only for wpe wifi
sudo ifconfig eth1 up
sudo iwlist eth1/wlan0 scan
sudo iwconfig etho essid <ESSID> key s:<PASSWORD>
sudo dhclient eth1
```

## route specific traffic to vpn
### [Configuring routes so that vpn is only used for local resources](https://askubuntu.com/questions/968464/configuring-routes-so-that-vpn-is-only-used-for-local-resources)
```bash
sudo ifmetric enp4s0 1
sudo ip route add 10.0.0.0/8 dev ppp0 metric 25
# test with traceroute -I XXXXXXXX
# test with route to check the route table
```

## [Chroot Jail](https://www.tecmint.com/restrict-ssh-user-to-directory-using-chrooted-jail/)
	git + git-receive-pack + git-upload-pack
	sgit

## Bluetooth
### [Bluetoothctl connects and disconnects repeatedly](https://superuser.com/questions/1160934/bluetoothctl-connects-and-disconnects-repeatedly)
```bash
bluetoothctl
scan on/off
power on
agent on
pair 0C:4D:12:11:01:E4
the pair code into the keyboard as prompted
connect 0C:4D:12:11:01:E4
trust 0C:4D:12:11:01:E4
agent off
quit
# pavucontrol -> choose output device
# for name or index number of possible sinks
pacmd list-sinks
pactl list short sinks

# to set the default output sink
pacmd set-default-sink "SINKNAME"
# to set the default input
pacmd set-default-source "SOURCENAME"
pacmd set-sink-volume index volume
# for volume control (0 = Mute, 65536 = 100%)
pacmd set-source-volume index volume
```

## VPN
### kjy
```bash
# list connection
nmcli con
# start connection
nmcli con up id connection_name
# down conection
nmcli con down id connection_name

sudo ifmetric wlp3s0 1
sudo ip route add 140.124.0.0/16 dev ppp0 metric 25
sudo traceroute -I youtube.com
```

## VirtualBox
### [shared folder](https://askubuntu.com/questions/456400/why-cant-i-access-a-shared-folder-from-within-my-virtualbox-machine)
```bash
apt-get install virtualbox-guest-dkms
```
## Setting
- 輸入法
[Hime](http://goodjack.blogspot.tw/2013/08/linux-phonetic-setting.html)

- 顯卡
[Nvidia](https://standbymesss.blogspot.tw/2016/09/ubuntu1404-nvidiadriver.html)

- Chrome
[address size](https://productforums.google.com/forum/#!topic/chrome/fZLk3jIw_z8)

- Font
[How To Make Ubuntu Look Like Mac (In 5 Steps)](http://www.omgubuntu.co.uk/2017/03/make-ubuntu-look-like-mac-5-steps)

- Launcher
[How to Convert the Unity Launcher into a Dock-Style Launcher](https://www.howtogeek.com/202708/how-to-convert-the-unity-launcher-into-a-dock-style-launcher/)

- multi-finger
    + [Multitouch gestures with libinput dirver on X11, Linux](https://github.com/iberianpig/fusuma)
    + [Setting up Touchpad Gestures in your Ubuntu Laptop](https://medium.com/@italohdc/setting-up-touchpad-gestures-in-your-ubuntu-laptop-dae7a5617f91)

- Function Key
    + [works for function+vloume](http://www.webupd8.org/2010/05/enable-fn-keys-on-your-asus-eeepc-and.html)
    +

- keyboard backlight
[cannot turn on keyboard backlight](https://askubuntu.com/questions/644410/cannot-turn-on-keyboard-backlight)
xset led on/off trun off/on the keyboard

- Afer installind
    + [9 Things To Do After Installing Ubuntu 16.04](https://itsfoss.com/things-to-do-after-installing-ubuntu-16-04/)
    + [Enable 'Minimise on Click'](http://www.omgubuntu.co.uk/2016/04/10-things-to-do-after-installing-ubuntu-16-04-lts)
    + [Showing all installed programs in Ubuntu](https://askubuntu.com/questions/717731/showing-all-installed-programs-in-ubuntu)

- Theme
    - [How can I install GTK themes on Ubuntu?](https://askubuntu.com/questions/213697/how-can-i-install-gtk-themes-on-ubuntu)
    + [Flat-Plat is The Best Material Design Theme for Linux](https://www.fossmint.com/flat-plat-theme-for-ubuntu-linux/)
    + [material designed icon](https://github.com/anmoljagetia/Flatabulous)
    + [Dash to Dock](https://micheleg.github.io/dash-to-dock/settings.html)
    + [wall paper](https://www.fossmint.com/material-inspired-themes-icons-for-ubuntu-linux/)
    + [How to Install Ubuntu Tweak in Ubuntu 16.04](http://ubuntuhandbook.org/index.php/2016/05/install-ubuntu-tweak-in-ubuntu-16-04/)
    + [gnome](https://www.opendesktop.org/s/Gnome)

- [restore session](http://www.webupd8.org/2016/03/how-to-save-and-restore-unity-session.html)


Archlinux
---
- [Arch Linux Installation and Configuration on UEFI Machines](https://www.tecmint.com/arch-linux-installation-and-configuration-guide/?utm_content=bufferc01f4&utm_medium=social&utm_source=facebook.com&utm_campaign=buffer)
